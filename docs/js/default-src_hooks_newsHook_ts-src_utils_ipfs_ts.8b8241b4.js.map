{"version":3,"file":"js/default-src_hooks_newsHook_ts-src_utils_ipfs_ts.8b8241b4.js","mappings":";oPAAO,IAAMA,EAAQ,QACRC,EAAc,cACdC,EAAQ,QACRC,EAAS,SACTC,EAAM,MACNC,EAAY,YACZC,EAAY,YACZC,EAAa,4jBCN1B,gtPA+BA,mBACE,IAAQC,GAAWC,EAAAA,EAAAA,KAAe,SAACC,GAAK,OAAKA,EAAMC,IAAI,IAA/CH,OACAI,GAAmBH,EAAAA,EAAAA,KAAe,SAACC,GAAK,OAAKA,EAAMG,MAAM,IAAzDD,eAEFE,EAAW,6BAAG,WAClBC,EACAC,GAAe,2FACmB,GAAlCC,EAAgC,EAAH,6BAAG,CAAC,EAE5BT,EAAQ,CAAF,gDACU,OAAbU,EAAkBF,EAAlBE,OAAQC,EAAUH,EAAVG,MAAK,SACAX,EAAOY,aAAaF,EAASC,GAAM,OAAlDE,EAAS,EAAH,KACNC,EAAMC,KAAKC,UAAU,EAAD,CACxBT,KAAAA,EACAU,WAAYb,GACTK,KAELS,EAAAA,EAAAA,IAAK,EAACC,EAAAA,EAAAA,GAAqBL,IAAOD,GAAO,2CAC1C,gBAdgB,wCAgBXO,EAAU,6BAAG,WAAOC,EAAMb,GAAM,uEAC9BC,EAAO,CAAEY,KAAAA,GACff,EAAYb,EAAAA,GAAae,EAAQC,GAAK,2CACvC,gBAHe,wCAKVa,EAAQ,6BAAG,WAAOd,GAAM,iEAC5BF,EAAYV,EAAAA,GAAKY,GAAO,2CACzB,gBAFa,sCAIRe,EAAW,6BAAG,WAAOf,EAAQC,GAAI,iEACrCH,EAAYZ,EAAAA,GAAOc,EAAQC,GAAK,2CACjC,gBAFgB,wCAIXe,EAAY,6BAAG,WAAOhB,EAAQC,GAAI,iEACtCH,EAAYX,EAAAA,GAAQa,EAAQC,GAAK,2CAClC,gBAFiB,wCAIZgB,EAAc,6BAAG,WAAOjB,GAAM,iEAElCF,EAAYT,EAAAA,GAAWW,GAAO,2CAC/B,gBAHmB,sCAKdkB,EAAe,6BAAG,WAAOlB,EAAQC,GAAI,iEACzCH,EAAYR,EAAAA,GAAWU,EAAQC,GAAK,2CACrC,gBAFoB,wCAIfkB,EAAgB,6BAAG,WAAOnB,EAAQC,GAAI,iEAC1CH,EAAYP,EAAAA,GAAYS,EAAQC,GAAK,2CACtC,gBAFqB,wCAItB,MAAO,CACLW,KAAAA,EACAE,IAAAA,EACAC,MAAAA,EACAC,OAAAA,EACAC,UAAAA,EACAC,UAAAA,EACAC,WAAAA,EAEH,ueC1FD,ovNACA,IAAIC,OAA0BC,EAExBC,EAAU,6BAAG,kFACbF,EAAO,CAAF,wCAASA,GAAK,wBACDG,EAAAA,EAAAA,MAAQ,gCAAtBH,EAAQ,EAAH,iDACd,kBAHe,mCAKHI,EAAG,6BAAG,WAAOC,GAAU,yFACfH,IAAY,OAArB,OAAJI,EAAO,EAAH,uBAGYA,EAAKF,IAAIC,GAAK,OAAvB,OAALE,EAAQ,EAAH,uBACJA,EAAMC,IAAIC,YAAU,wCAErBC,MAAM,EAAD,IAAiB,0DAE/B,gBATe,sCA8BHC,EAAO,SAACC,GAAY,qCAAqCA,EAAI","sources":["webpack://sourcedao-pc-dapp/./src/constants/libp2p.ts","webpack://sourcedao-pc-dapp/./src/hooks/newsHook.ts","webpack://sourcedao-pc-dapp/./src/utils/ipfs.ts"],"sourcesContent":["export const GREET = 'greet'\r\nexport const INFORMATION = 'information'\r\nexport const OFFER = 'offer'\r\nexport const ANSWER = 'answer'\r\nexport const OUT = 'out'\r\nexport const DISCOVERY = 'discovery'\r\nexport const ROOMOFFER = 'roomOffer'\r\nexport const ROOMANSWER = 'roomAnswer'","import { pipe } from 'it-pipe'\r\n\r\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\r\n\r\nimport { useAppSelector } from '@store/index'\r\n\r\nimport {\r\n  ANSWER,\r\n  INFORMATION,\r\n  OFFER,\r\n  OUT,\r\n  DISCOVERY,\r\n  ROOMOFFER,\r\n  ROOMANSWER,\r\n} from '@constants/libp2p'\r\n\r\nimport type { Friends } from '@store/modules/friends'\r\n\r\nexport type Send = (data: string, firend: Friends) => void\r\nexport type Out = (firend: Friends) => void\r\nexport type News = (firend: Friends, data: Record<string, unknown>) => void\r\n\r\ninterface NewsResult {\r\n  send: Send\r\n  out: Out\r\n  offer: News\r\n  answer: News\r\n  discovery: Out\r\n  roomOffer: News\r\n  roomAnswer: News\r\n}\r\n\r\nexport default (): NewsResult => {\r\n  const { libp2p } = useAppSelector((state) => state.user)\r\n  const { accountAddress } = useAppSelector((state) => state.wallet)\r\n\r\n  const privateSend = async (\r\n    type: string,\r\n    friend: Friends,\r\n    data: Record<string, unknown> = {}\r\n  ) => {\r\n    if (!libp2p) return\r\n    const { peerId, topic } = friend\r\n    const stream = await libp2p.dialProtocol(peerId!, topic)\r\n    const val = JSON.stringify({\r\n      type,\r\n      account_id: accountAddress,\r\n      ...data,\r\n    })\r\n    pipe([uint8ArrayFromString(val)], stream)\r\n  }\r\n\r\n  const send: Send = async (text, friend) => {\r\n    const data = { text }\r\n    privateSend(INFORMATION, friend, data)\r\n  }\r\n\r\n  const out: Out = async (friend) => {\r\n    privateSend(OUT, friend)\r\n  }\r\n\r\n  const offer: News = async (friend, data) => {\r\n    privateSend(OFFER, friend, data)\r\n  }\r\n\r\n  const answer: News = async (friend, data) => {\r\n    privateSend(ANSWER, friend, data)\r\n  }\r\n\r\n  const discovery: Out = async (friend) => {\r\n    \r\n    privateSend(DISCOVERY, friend)\r\n  }\r\n\r\n  const roomOffer: News = async (friend, data) => {\r\n    privateSend(ROOMOFFER, friend, data)\r\n  }\r\n\r\n  const roomAnswer: News = async (friend, data) => {\r\n    privateSend(ROOMANSWER, friend, data)\r\n  }\r\n\r\n  return {\r\n    send,\r\n    out,\r\n    offer,\r\n    answer,\r\n    discovery,\r\n    roomOffer,\r\n    roomAnswer,\r\n  }\r\n}\r\n","import { create, IPFS } from 'ipfs-core'\r\n\r\nlet _ipfs: IPFS | undefined = undefined\r\n\r\nconst createIpfs = async () => {\r\n  if (_ipfs) return _ipfs\r\n  return (_ipfs = await create())\r\n}\r\n\r\nexport const add = async (file: File): Promise<string> => {\r\n  const ipfs = await createIpfs()\r\n\r\n  try {\r\n    const added = await ipfs.add(file)\r\n    return added.cid.toString()\r\n  } catch (error) {\r\n    throw Error(error as string)\r\n  }\r\n}\r\n\r\nexport const cat = async <T>(cids: string[]): Promise<T[]> => {\r\n  const ipfs = await createIpfs()\r\n\r\n  const examJson: Promise<T>[] = []\r\n\r\n  cids.forEach((cid) => {\r\n    examJson.push(\r\n      new Promise(async (resolve) => {\r\n        const cated = await ipfs.cat(cid)\r\n        for await (const current of cated) {\r\n          resolve(JSON.parse(utf8ArrayToStr(current)))\r\n        }\r\n      })\r\n    )\r\n  })\r\n\r\n  return await Promise.all(examJson)\r\n}\r\n\r\nexport const path = (hash: string): string => `https://ipfs.io/ipfs/${hash}`\r\n\r\nconst utf8ArrayToStr = (array: Uint8Array): string => {\r\n  const len = array.length\r\n  let out, i, c, char2, char3\r\n\r\n  out = ''\r\n\r\n  i = 0\r\n  while (i < len) {\r\n    c = array[i++]\r\n    switch (c >> 4) {\r\n      case 0:\r\n      case 1:\r\n      case 2:\r\n      case 3:\r\n      case 4:\r\n      case 5:\r\n      case 6:\r\n      case 7:\r\n        out += String.fromCharCode(c)\r\n        break\r\n      case 12:\r\n      case 13:\r\n        char2 = array[i++]\r\n        out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f))\r\n        break\r\n      case 14:\r\n        char2 = array[i++]\r\n        char3 = array[i++]\r\n        out += String.fromCharCode(\r\n          ((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0)\r\n        )\r\n        break\r\n    }\r\n  }\r\n\r\n  return out\r\n}\r\n"],"names":["GREET","INFORMATION","OFFER","ANSWER","OUT","DISCOVERY","ROOMOFFER","ROOMANSWER","libp2p","useAppSelector","state","user","accountAddress","wallet","privateSend","type","friend","data","peerId","topic","dialProtocol","stream","val","JSON","stringify","account_id","pipe","uint8ArrayFromString","send","text","out","offer","answer","discovery","roomOffer","roomAnswer","_ipfs","undefined","createIpfs","create","add","file","ipfs","added","cid","toString","Error","path","hash"],"sourceRoot":""}