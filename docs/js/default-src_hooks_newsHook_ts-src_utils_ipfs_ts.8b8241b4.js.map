{"version":3,"file":"js/default-src_hooks_newsHook_ts-src_utils_ipfs_ts.8b8241b4.js","mappings":";oPAAO,IAAMA,EAAQ,QACRC,EAAc,cACdC,EAAQ,QACRC,EAAS,SACTC,EAAM,MACNC,EAAY,YACZC,EAAY,YACZC,EAAa,4jBCN1B,gtPA+BA,mBACE,IAAQC,GAAWC,EAAAA,EAAAA,KAAe,SAACC,GAAK,OAAKA,EAAMC,IAAI,IAA/CH,OACAI,GAAmBH,EAAAA,EAAAA,KAAe,SAACC,GAAK,OAAKA,EAAMG,MAAM,IAAzDD,eAEFE,EAAW,6BAAG,WAClBC,EACAC,GAAe,2FACmB,GAAlCC,EAAgC,EAAH,6BAAG,CAAC,EAE5BT,EAAQ,CAAF,gDACU,OAAbU,EAAkBF,EAAlBE,OAAQC,EAAUH,EAAVG,MAAK,SACAX,EAAOY,aAAaF,EAASC,GAAM,OAAlDE,EAAS,EAAH,KACNC,EAAMC,KAAKC,UAAU,EAAD,CACxBT,KAAAA,EACAU,WAAYb,GACTK,KAELS,EAAAA,EAAAA,IAAK,EAACC,EAAAA,EAAAA,GAAqBL,IAAOD,GAAO,2CAC1C,gBAdgB,wCAgBXO,EAAU,6BAAG,WAAOC,EAAMb,GAAM,uEAC9BC,EAAO,CAAEY,KAAAA,GACff,EAAYb,EAAAA,GAAae,EAAQC,GAAK,2CACvC,gBAHe,wCAKVa,EAAQ,6BAAG,WAAOd,GAAM,iEAC5BF,EAAYV,EAAAA,GAAKY,GAAO,2CACzB,gBAFa,sCAIRe,EAAW,6BAAG,WAAOf,EAAQC,GAAI,iEACrCH,EAAYZ,EAAAA,GAAOc,EAAQC,GAAK,2CACjC,gBAFgB,wCAIXe,EAAY,6BAAG,WAAOhB,EAAQC,GAAI,iEACtCH,EAAYX,EAAAA,GAAQa,EAAQC,GAAK,2CAClC,gBAFiB,wCAIZgB,EAAc,6BAAG,WAAOjB,GAAM,iEAElCF,EAAYT,EAAAA,GAAWW,GAAO,2CAC/B,gBAHmB,sCAKdkB,EAAe,6BAAG,WAAOlB,EAAQC,GAAI,iEACzCH,EAAYR,EAAAA,GAAWU,EAAQC,GAAK,2CACrC,gBAFoB,wCAIfkB,EAAgB,6BAAG,WAAOnB,EAAQC,GAAI,iEAC1CH,EAAYP,EAAAA,GAAYS,EAAQC,GAAK,2CACtC,gBAFqB,wCAItB,MAAO,CACLW,KAAAA,EACAE,IAAAA,EACAC,MAAAA,EACAC,OAAAA,EACAC,UAAAA,EACAC,UAAAA,EACAC,WAAAA,EAEH,ueC1FD,ovNACA,IAAIC,OAA0BC,EAExBC,EAAU,6BAAG,kFACbF,EAAO,CAAF,wCAASA,GAAK,wBACDG,EAAAA,EAAAA,MAAQ,gCAAtBH,EAAQ,EAAH,iDACd,kBAHe,mCAKHI,EAAG,6BAAG,WAAOC,GAAU,yFACfH,IAAY,OAArB,OAAJI,EAAO,EAAH,uBAGYA,EAAKF,IAAIC,GAAK,OAAvB,OAALE,EAAQ,EAAH,uBACJA,EAAMC,IAAIC,YAAU,wCAErBC,MAAM,EAAD,IAAiB,0DAE/B,gBATe,sCA8BHC,EAAO,SAACC,GAAY,qCAAqCA,EAAI","sources":["webpack://sourcedao-pc-dapp/./src/constants/libp2p.ts","webpack://sourcedao-pc-dapp/./src/hooks/newsHook.ts","webpack://sourcedao-pc-dapp/./src/utils/ipfs.ts"],"sourcesContent":["export const GREET = 'greet'\nexport const INFORMATION = 'information'\nexport const OFFER = 'offer'\nexport const ANSWER = 'answer'\nexport const OUT = 'out'\nexport const DISCOVERY = 'discovery'\nexport const ROOMOFFER = 'roomOffer'\nexport const ROOMANSWER = 'roomAnswer'","import { pipe } from 'it-pipe'\n\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nimport { useAppSelector } from '@store/index'\n\nimport {\n  ANSWER,\n  INFORMATION,\n  OFFER,\n  OUT,\n  DISCOVERY,\n  ROOMOFFER,\n  ROOMANSWER,\n} from '@constants/libp2p'\n\nimport type { Friends } from '@store/modules/friends'\n\nexport type Send = (data: string, firend: Friends) => void\nexport type Out = (firend: Friends) => void\nexport type News = (firend: Friends, data: Record<string, unknown>) => void\n\ninterface NewsResult {\n  send: Send\n  out: Out\n  offer: News\n  answer: News\n  discovery: Out\n  roomOffer: News\n  roomAnswer: News\n}\n\nexport default (): NewsResult => {\n  const { libp2p } = useAppSelector((state) => state.user)\n  const { accountAddress } = useAppSelector((state) => state.wallet)\n\n  const privateSend = async (\n    type: string,\n    friend: Friends,\n    data: Record<string, unknown> = {}\n  ) => {\n    if (!libp2p) return\n    const { peerId, topic } = friend\n    const stream = await libp2p.dialProtocol(peerId!, topic)\n    const val = JSON.stringify({\n      type,\n      account_id: accountAddress,\n      ...data,\n    })\n    pipe([uint8ArrayFromString(val)], stream)\n  }\n\n  const send: Send = async (text, friend) => {\n    const data = { text }\n    privateSend(INFORMATION, friend, data)\n  }\n\n  const out: Out = async (friend) => {\n    privateSend(OUT, friend)\n  }\n\n  const offer: News = async (friend, data) => {\n    privateSend(OFFER, friend, data)\n  }\n\n  const answer: News = async (friend, data) => {\n    privateSend(ANSWER, friend, data)\n  }\n\n  const discovery: Out = async (friend) => {\n    \n    privateSend(DISCOVERY, friend)\n  }\n\n  const roomOffer: News = async (friend, data) => {\n    privateSend(ROOMOFFER, friend, data)\n  }\n\n  const roomAnswer: News = async (friend, data) => {\n    privateSend(ROOMANSWER, friend, data)\n  }\n\n  return {\n    send,\n    out,\n    offer,\n    answer,\n    discovery,\n    roomOffer,\n    roomAnswer,\n  }\n}\n","import { create, IPFS } from 'ipfs-core'\n\nlet _ipfs: IPFS | undefined = undefined\n\nconst createIpfs = async () => {\n  if (_ipfs) return _ipfs\n  return (_ipfs = await create())\n}\n\nexport const add = async (file: File): Promise<string> => {\n  const ipfs = await createIpfs()\n\n  try {\n    const added = await ipfs.add(file)\n    return added.cid.toString()\n  } catch (error) {\n    throw Error(error as string)\n  }\n}\n\nexport const cat = async <T>(cids: string[]): Promise<T[]> => {\n  const ipfs = await createIpfs()\n\n  const examJson: Promise<T>[] = []\n\n  cids.forEach((cid) => {\n    examJson.push(\n      new Promise(async (resolve) => {\n        const cated = await ipfs.cat(cid)\n        for await (const current of cated) {\n          resolve(JSON.parse(utf8ArrayToStr(current)))\n        }\n      })\n    )\n  })\n\n  return await Promise.all(examJson)\n}\n\nexport const path = (hash: string): string => `https://ipfs.io/ipfs/${hash}`\n\nconst utf8ArrayToStr = (array: Uint8Array): string => {\n  const len = array.length\n  let out, i, c, char2, char3\n\n  out = ''\n\n  i = 0\n  while (i < len) {\n    c = array[i++]\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        out += String.fromCharCode(c)\n        break\n      case 12:\n      case 13:\n        char2 = array[i++]\n        out += String.fromCharCode(((c & 0x1f) << 6) | (char2 & 0x3f))\n        break\n      case 14:\n        char2 = array[i++]\n        char3 = array[i++]\n        out += String.fromCharCode(\n          ((c & 0x0f) << 12) | ((char2 & 0x3f) << 6) | ((char3 & 0x3f) << 0)\n        )\n        break\n    }\n  }\n\n  return out\n}\n"],"names":["GREET","INFORMATION","OFFER","ANSWER","OUT","DISCOVERY","ROOMOFFER","ROOMANSWER","libp2p","useAppSelector","state","user","accountAddress","wallet","privateSend","type","friend","data","peerId","topic","dialProtocol","stream","val","JSON","stringify","account_id","pipe","uint8ArrayFromString","send","text","out","offer","answer","discovery","roomOffer","roomAnswer","_ipfs","undefined","createIpfs","create","add","file","ipfs","added","cid","toString","Error","path","hash"],"sourceRoot":""}