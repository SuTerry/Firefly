"use strict";(self.webpackChunksourcedao_pc_dapp=self.webpackChunksourcedao_pc_dapp||[]).push([["node_modules_lingo3d-react_dist_MeshReflectorMaterial_fbc36eec_mjs"],{49401:(e,t,r)=>{r.r(t),r.d(t,{default:()=>o});var i=r(51231);r(44441),r(48099);class o extends i.M{constructor(e,t,r,o,{mixBlur:a=0,mixStrength:n=1,resolution:s=256,blur:l=[0,0],minDepthThreshold:h=.9,maxDepthThreshold:m=1,depthScale:f=0,depthToBlurRatioBias:d=.25,mirror:u=0,distortion:c=1,mixContrast:p=1,distortionMap:x,reflectorOffset:v=0,planeNormal:g=new i.a(0,0,1)}={}){super(),this.gl=e,this.camera=t,this.scene=r,this.parent=o,this.hasBlur=l[0]+l[1]>0,this.reflectorPlane=new i.au,this.normal=new i.a,this.reflectorWorldPosition=new i.a,this.cameraWorldPosition=new i.a,this.rotationMatrix=new i.g,this.lookAtPosition=new i.a(0,-1,0),this.clipPlane=new i.V,this.view=new i.a,this.target=new i.a,this.q=new i.V,this.textureMatrix=new i.g,this.virtualCamera=new i.i,this.reflectorOffset=v,this.planeNormal=g,this.setupBuffers(s,l),this.reflectorProps={mirror:u,textureMatrix:this.textureMatrix,mixBlur:a,tDiffuse:this.fbo1.texture,tDepth:this.fbo1.depthTexture,tDiffuseBlur:this.fbo2.texture,hasBlur:this.hasBlur,mixStrength:n,minDepthThreshold:h,maxDepthThreshold:m,depthScale:f,depthToBlurRatioBias:d,distortion:c,distortionMap:x,mixContrast:p,"defines-USE_BLUR":this.hasBlur?"":void 0,"defines-USE_DEPTH":f>0?"":void 0,"defines-USE_DISTORTION":x?"":void 0}}setupBuffers(e,t){const r={minFilter:i.Z,magFilter:i.Z,encoding:this.gl.outputEncoding},o=new i.av(e,e,r);o.depthBuffer=!0,o.depthTexture=new i.aw(e,e),o.depthTexture.format=i.ax,o.depthTexture.type=i.ay;const a=new i.av(e,e,r);this.fbo1=o,this.fbo2=a,this.kawaseBlurPass=new i.az,this.kawaseBlurPass.setSize(t[0],t[1])}beforeRender(){if(!this.parent||(this.reflectorWorldPosition.setFromMatrixPosition(this.parent.matrixWorld),this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld),this.rotationMatrix.extractRotation(this.parent.matrixWorld),this.normal.copy(this.planeNormal),this.normal.applyMatrix4(this.rotationMatrix),this.reflectorWorldPosition.addScaledVector(this.normal,this.reflectorOffset),this.view.subVectors(this.reflectorWorldPosition,this.cameraWorldPosition),this.view.dot(this.normal)>0))return;this.view.reflect(this.normal).negate(),this.view.add(this.reflectorWorldPosition),this.rotationMatrix.extractRotation(this.camera.matrixWorld),this.lookAtPosition.set(0,0,-1),this.lookAtPosition.applyMatrix4(this.rotationMatrix),this.lookAtPosition.add(this.cameraWorldPosition),this.target.subVectors(this.reflectorWorldPosition,this.lookAtPosition),this.target.reflect(this.normal).negate(),this.target.add(this.reflectorWorldPosition),this.virtualCamera.position.copy(this.view),this.virtualCamera.up.set(0,1,0),this.virtualCamera.up.applyMatrix4(this.rotationMatrix),this.virtualCamera.up.reflect(this.normal),this.virtualCamera.lookAt(this.target),this.virtualCamera.far=this.camera.far,this.virtualCamera.updateMatrixWorld(),this.virtualCamera.projectionMatrix.copy(this.camera.projectionMatrix),this.textureMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),this.textureMatrix.multiply(this.virtualCamera.projectionMatrix),this.textureMatrix.multiply(this.virtualCamera.matrixWorldInverse),this.textureMatrix.multiply(this.parent.matrixWorld),this.reflectorPlane.setFromNormalAndCoplanarPoint(this.normal,this.reflectorWorldPosition),this.reflectorPlane.applyMatrix4(this.virtualCamera.matrixWorldInverse),this.clipPlane.set(this.reflectorPlane.normal.x,this.reflectorPlane.normal.y,this.reflectorPlane.normal.z,this.reflectorPlane.constant);const e=this.virtualCamera.projectionMatrix;this.q.x=(Math.sign(this.clipPlane.x)+e.elements[8])/e.elements[0],this.q.y=(Math.sign(this.clipPlane.y)+e.elements[9])/e.elements[5],this.q.z=-1,this.q.w=(1+e.elements[10])/e.elements[14],this.clipPlane.multiplyScalar(2/this.clipPlane.dot(this.q)),e.elements[2]=this.clipPlane.x,e.elements[6]=this.clipPlane.y,e.elements[10]=this.clipPlane.z+1,e.elements[14]=this.clipPlane.w}update(){if(this.parent.material!==this)return;this.parent.visible=!1;const e=this.gl.xr.enabled,t=this.gl.shadowMap.autoUpdate;this.beforeRender(),this.gl.xr.enabled=!1,this.gl.shadowMap.autoUpdate=!1,this.gl.setRenderTarget(this.fbo1),this.gl.state.buffers.depth.setMask(!0),this.gl.autoClear||this.gl.clear(),this.gl.render(this.scene,this.virtualCamera),this.hasBlur&&this.kawaseBlurPass.render(this.gl,this.fbo1,this.fbo2),this.gl.xr.enabled=e,this.gl.shadowMap.autoUpdate=t,this.parent.visible=!0,this.gl.setRenderTarget(null)}onBeforeCompile(e,...t){super.onBeforeCompile(e,...t),void 0===this.defines&&(this.defines={}),this.defines.USE_UV||(this.defines.USE_UV=""),void 0!==this.reflectorProps["defines-USE_BLUR"]&&(this.defines.USE_BLUR=""),void 0!==this.reflectorProps["defines-USE_DEPTH"]&&(this.defines.USE_DEPTH=""),void 0!==this.reflectorProps["defines-USE_DISTORTION"]&&(this.defines.USE_DISTORTION="");let r=this.reflectorProps;for(let t in r)e.uniforms[t]={get value(){return r[t]}};e.vertexShader=`\n              uniform mat4 textureMatrix;\n              varying vec4 my_vUv;     \n            ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","\n            #include <project_vertex>\n            my_vUv = textureMatrix * vec4( position, 1.0 );\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            "),e.fragmentShader=`\n              uniform sampler2D tDiffuse;\n              uniform sampler2D tDiffuseBlur;\n              uniform sampler2D tDepth;\n              uniform sampler2D distortionMap;\n              uniform float distortion;\n              uniform float cameraNear;\n              uniform float cameraFar;\n              uniform bool hasBlur;\n              uniform float mixBlur;\n              uniform float mirror;\n              uniform float mixStrength;\n              uniform float minDepthThreshold;\n              uniform float maxDepthThreshold;\n              uniform float mixContrast;\n              uniform float depthScale;\n              uniform float depthToBlurRatioBias;\n              varying vec4 my_vUv;        \n              ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","\n            #include <emissivemap_fragment>\n          \n            float distortionFactor = 0.0;\n            #ifdef USE_DISTORTION\n              distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n            #endif\n      \n            vec4 new_vUv = my_vUv;\n            new_vUv.x += distortionFactor;\n            new_vUv.y += distortionFactor;\n      \n            vec4 base = texture2DProj(tDiffuse, new_vUv);\n            vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n            \n            vec4 merge = base;\n            \n            #ifdef USE_NORMALMAP\n              vec2 normal_uv = vec2(0.0);\n              vec4 normalColor = texture2D(normalMap, vUv);\n              vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n              vec3 coord = new_vUv.xyz / new_vUv.w;\n              normal_uv = coord.xy + coord.z * my_normal.xz * 0.05 * normalScale;\n              vec4 base_normal = texture2D(tDiffuse, normal_uv);\n              vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n              merge = base_normal;\n              blur = blur_normal;\n            #endif\n      \n            float depthFactor = 0.0001;\n            float blurFactor = 0.0;\n      \n            #ifdef USE_DEPTH\n              vec4 depth = texture2DProj(tDepth, new_vUv);\n              depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n              depthFactor *= depthScale;\n              depthFactor = max(0.0001, min(1.0, depthFactor));\n      \n              #ifdef USE_BLUR\n                blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n                merge = merge * min(1.0, depthFactor + 0.5);\n              #else\n                merge = merge * depthFactor;\n              #endif\n        \n            #endif\n      \n            float reflectorRoughnessFactor = roughness;\n            #ifdef USE_ROUGHNESSMAP\n              vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n              \n              reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n            #endif\n            \n            #ifdef USE_BLUR\n              blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n              merge = mix(merge, blur, blurFactor);\n            #endif\n      \n            vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n            newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n            newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n            newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n            \n            diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\n            ")}}}}]);
//# sourceMappingURL=node_modules_lingo3d-react_dist_MeshReflectorMaterial_fbc36eec_mjs.da588eb5.js.map